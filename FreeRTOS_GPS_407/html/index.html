<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Hoofdpagina</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project<span id="projectnumber">&#160;11</span>
   </div>
   <div id="projectbrief">RTOS doxygen</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Hoofdpagina </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="mainpage"></a></p>
<p><span style="font-family:&apos;Corbel&apos;; font-size:10pt; color:green"><b>Over deze pagina.</b> Deze pagina (..\Doxygen\<b>mainpage.md</b>) is een .md markdown-bestand, gemaakt met Typora (gratis download: <a href="https://typora.en.uptodown.com/windows/download">https://typora.en.uptodown.com/windows/download</a>), aangevuld met html (markdown kun je mixen met html). Zo kun je redelijk simpel zelf een hoofdpagina maken, die Doxygen dan gebruikt (ipv de standaard Doxygen-mainpage); dit wordt dan deze <b>index.html</b>.<br  />
 Het is geïnstalleerd via de Doxygen Wizard, tab [Expert mode]:<br  />
 &#160;&#160;&#160; INPUT = mainpage.md<br  />
 &#160;&#160;&#160; USE_MDFILE_AS_MAINPAGE = mainpage.md<br  />
 Bestand <b>..\Doxyfile</b> is de doxygen projectfile. De outputmap van doxygen is <b>..\Doxygen\html</b><br  />
NB. Als je deze pagina verandert, moet je uiteraard wel eerst doxygen runnen (via tab [Run]) om aanpassingen te zien. </span></p>
<p><span style="font-family:&apos;Corbel&apos;; font-size:12pt;">    </span></p>
<p><span style="font-family:&apos;Corbel&apos;; font-size:12pt;"><br  />
</span></p>
<p><span style="font-family:&apos;Corbel&apos;; font-size:12pt;"></p><h1 style="font-family:&apos;Corbel&apos;;">FreeRTOS documentatie</h1>
<p></span></p>
<p><span style="font-family:&apos;Corbel&apos;; font-size:12pt;"></span></p>
<p><span style="font-family:&apos;Corbel&apos;; font-size:12pt;">Het realtime OS FreeRTOS hebben we gekozen omdat het gratis is, open source is, veel gebruikt wordt, relatief eenvoudig is én... omdat het uitgebreid gedocumenteerd is. Dat betekent dat het lesmateriaal grotendeels online te vinden is (en niet op powerpoints herhaald hoeft te worden). De belangrijkste bronnen zijn:</span></p>
<p><span style="font-family:&apos;Corbel&apos;; font-size:12pt;"></p><ul style="font-family:&apos;Corbel&apos;;">
<li>
<b>FREERTOS hoofddocumentatie</b>: de <a href="https://www.freertos.org/a00106.html">API-Reference</a>. <u>Bij het ontwikkelen en de lessen moet je die er constant bij houden.</u>  </li>
<li>
<a href="https://www.freertos.org/Documentation/RTOS_book.html">FreeRTOS boeken en pdf's</a> </li>
</ul>
<p></span></p>
<p><span style="font-family:&apos;Corbel&apos;; font-size:12pt;"><br  />
 </p><h1 style="font-family:&apos;Corbel&apos;;">Installatie: hoe krijg je de applicatie aan de praat?</h1>
<p></span></p>
<p><span style="font-family:&apos;Corbel&apos;; font-size:12pt;"> </p><ul style="font-family:&apos;Corbel&apos;;">
<li>
Installeer het project FreeRTOS_GPS_407 in <a href="https://www.st.com/en/development-tools/stm32cubeide.html">STM32CubeIDE</a>. <ul style="font-family:&apos;Corbel&apos;;font-size:11pt;">
<li>
zip-bestand downloaden en uitpakken in map </li>
<li>
STMCubeIDE starten </li>
<li>
Nieuwe Workspace </li>
<li>
File -&gt; Import -&gt; General -&gt; Atollic TrueSTUDIO Project </li>
</ul>
</li>
<li>
Sluit het ARM-bordje aan via USB. </li>
<li>
Flash de applicatie naar het ARM-bordje (bv. via debug). </li>
<li>
Download en installeer op je laptop een terminal-rs232-programma, bv. terminal.exe, of TeraTerm of iets anders. Zet de comport op 115200,n,8,1. Zet bij Transmit [CR]=[CR]+[LF] (dan wordt na &lt;Enter&gt; automatisch een Linefeed-character toegevoegd.  </li>
<li>
Reset het ARM-bordje en als het goed is zie je nu tekst verschijnen op het terminalprogramma.  </li>
</ul>
<p><br  />
</span></p>
<p><span style="font-family:&apos;Corbel&apos;; font-size:12pt;"></p><h1 style="font-family:&apos;Corbel&apos;;">Werking: wat doet de applicatie?</h1>
<p></span></p>
<p><span style="font-family:&apos;Corbel&apos;; font-size:12pt;"> De applicatie freeRTOS_GPS_407 (geschikt voor ARM Cortex 407) is een werkende freeRTOS-applicatie, met de volgende doelen:</span></p>
<p><span style="font-family:&apos;Corbel&apos;; font-size:12pt;"></p><ul style="font-family:&apos;Corbel&apos;;">
<li>
<b>didactisch</b>. Het toont de opzet en werking van verschillende freeRTOS-mechanismen. Soms is in de code op didactische gronden gekozen voor een of ander mechanisme, terwijl dit ook anders opgelost had kunnen worden. </li>
<li>
<b>als basis (skeleton) om verder uit te werken voor het project</b>. Nu hoef je als student niet alles from scratch zelf te bouwen. Het is wel aan jou om goed te kijken welke onderdelen van de code je voor jouw applicatie kunt gebruiken en welke je kunt verwijderen. </li>
</ul>
<p></span></p>
<p><span style="font-family:&apos;Corbel&apos;; font-size:12pt;">Als de de installatie gelukt is (zie boven), en het ARM-bordje communiceert met je laptop via een terminalprogramma, dan zie je dit:</span></p>
<p><span style="font-family:&apos;Corbel&apos;; font-size:12pt;"></p><ul style="font-family:&apos;Corbel&apos;;">
<li>
Het display toont het versienummer (<a class="el" href="main_8c.html" title=": Main program body">main.c</a>, <a class="el" href="admin_8c.html" title="Bestaat uit 3 onderdelen:   Deel 1. Initialisatieoutput naar uart en lcd-scherm.  Deel 2....">admin.c</a>) </li>
<li>
De applicatie stuurt de rij ledjes aan (<a class="el" href="ledjes_8c.html" title="Laat de werking van mutexes en tasknotification zien.  Demonstreert: , xSemaphoreTake(),...">ledjes.c</a>). </li>
<li>
Het blauwe ledje wordt elke halve seconde aan- en uitgezet (<a class="el" href="admin_8c.html" title="Bestaat uit 3 onderdelen:   Deel 1. Initialisatieoutput naar uart en lcd-scherm.  Deel 2....">admin.c</a>). </li>
<li>
De applicatie leest de ARM-keys in (<a class="el" href="_a_r_m__keys_8c.html" title="Behandelt de communicatie met de ARM-toetsjes met: Eventgroups, TaskNotify, Interrupt-handling....">ARM_keys.c</a>, en <a class="el" href="stm32f4xx__it_8c.html" title="Interrupt Service Routines.">stm32f4xx_it.c</a>). Na elke toets zie je de ledjes rood, oranje en groen oplichten. </li>
<li>
De applicatie heeft een user interface via de UART (<a class="el" href="main_8c.html" title=": Main program body">main.c</a>). Het menu geeft keurig aan welke toetsen gebruikt kunnen worden (<a class="el" href="_u_a_r_t__keys_8c.html" title="Behandelt de communicatie met de UART.  Demonstreert: IRQ-handling, queue-handling,...">UART_keys.c</a>).  <ul style="list-style-type:none;">
<li>
<b>MENU:</b> </li>
<li>
<b>0</b>: <em>On/Off ALL test output.</em> Bij '0'&lt;enter&gt; krijg je of ALLE of GEEN testoutput te zien. </li>
<li>
<b>1</b>: <em>On/Off LEDS output.</em> Bij '1'&lt;enter&gt; gaan de LED-tasken WEL of GEEN output genereren.' </li>
<li>
<b>2</b>: <em>On/Off ARM_keys output.</em> Bij '2'&lt;enter&gt; gaan de ARM-keys-tasken WEL of GEEN output genereren.' </li>
<li>
<b>3</b>: <em>On/Off UART_keys output.</em> Bij '3'&lt;enter&gt; gaan de UART-keys-tasken WEL of GEEN output genereren.' </li>
<li>
<b>4</b>: <em>On/Off STUDENT output.</em>  Toets '4'&lt;enter&gt; kun je gebruiken voor je eigen testoutput. </li>
<li>
<b>5</b>: On/Off GPS processed data output (mits een GPS-receiver aangesloten is). </li>
<li>
<b>6</b>: On/Off GPS raw incoming data output. </li>
<li>
<b>d</b>: <em>change Delay time.</em> De LED-tasks werken met een delay time van default 200 MSecs tussen elke LED-setting. Zo kun je zien wat er gebeurt. Voorbeeld: 'd,50'&lt;enter&gt; verkleint de default delay time naar 50 MSecs, dus de ledjes gaan 4x zo snel. </li>
<li>
<b>m</b>: <em>show Menu</em>. Dit menu wordt getoond. </li>
<li>
<b>t</b>: <em>display Task-data.</em> Na 't'&lt;enter&gt; krijg je de gegevens per task te zien, zoals: nummer, prioriteit en geheugen (stack) gebruik. Zo kun je code optimaliseren en zien of een taak dreigt te weinig geheugen te krijgen... </li>
<li>
<b>p</b>: <em>change Priority of task</em>. Met 'p'[,tasknummer, prioriteit]&lt;enter&gt; kun je de prioriteit van een task aanpassen en zien wat er gebeurt. Voorbeeld: 'p,7,20' verandert de prioriteit van task 7 naar 20. </li>
<li>
<b>s</b>: <em>Start/stop task.</em> Na 's'[,tasknummer]&lt;enter&gt; kun je de task stoppen en starten. </li>
<li>
<b>w</b>: <em>Show waypoint data.</em> Na 'w'&lt;enter&gt; toon alle opgeslagen data uit de waypoints. </li>
<li>
<b>h</b>: <em>Print logs.</em> Na 'h'&lt;enter&gt; toon alle inputs en outputs. (Gps data, motor aansturing, ingedrukte knoppen enz.) </li>
<li>
<b>c</b>: <em>Change current waypoint.</em> Met 'c'[,Waypointnummer]&lt;enter&gt; kun je de huidige waypoint veranderen naar een andere Voorbeeld: 'c,4' verandert de waypoint counter naar 4. </li>
<li>
<b>r</b>: <em>Change waypoint data.</em> Met 'r'&lt;enter&gt; vervang je de huidige waypoint met de huidige data van uit de gps. </li>
<li>
<b>g</b>: <em>Print Parsed GPS data.</em> Met 'g'&lt;enter&gt; print je de omgezette data uit. Dit is handig voor debug. </li>
</ul>
</li>
</ul>
<p></span></p>
<p><span style="font-family:&apos;Corbel&apos;; font-size:12pt;"><br  />
 </p><h1 style="font-family:&apos;Corbel&apos;;">Design: overview van de applicatie</h1>
<p></span></p>
<p><span style="font-family:&apos;Corbel&apos;; font-size:12pt;"></span></p>
<p><span style="font-family:&apos;Corbel&apos;; font-size:12pt;">Hieronder zie je het <em>graphical design</em> van de applicatie (gemaakt in Powerpoint).<br  />
 Het doel van het graphisch design is om snel inzicht te krijgen in de samenhang en werking van de applicatie. Daarom zijn alleen de belangrijkste zaken weergegeven.</span></p>
<p><span style="font-family:&apos;Corbel&apos;; font-size:12pt;"><img src="../FreeRTOS_GPS_407_design" alt="FreeRTOS_GPS design" width="100%" class="inline"/></span></p>
<p><span style="font-family:&apos;Corbel&apos;; font-size:12pt;">De verschillende elementen: </p><ul style="font-family:&apos;Corbel&apos;;">
<li>
<em>I/O-laag.</em> Links zie je de ARM-inputs (UART en ARM-toetsen), rechts de ARM-outputs (UART, LCD, Buzzer, RGBY-leds en de LED-rij). De applicatie gebruikt deze I/O's om te laten zien hoe multitasking werkt met de FreeRTOS-mechanismen.  </li>
<li>
<em>Tasks.</em> Elke task bestaat uit een gekleurd blokje met titel en 'sourcecode'. Bijbehorende tasks zijn per kleur gegroepeerd. Zoals je ziet zijn er 3 task-groepen: <ul>
<li>
<em>Blauw.</em> Eigenlijk is dit de User Interface via de UART. Het leest en interpreteert de commando's die de gebruiker via een terminalprogramma intikt. Daarnaast schrijft het naar de gebruiker het menu en het programmaverloop. </li>
<li>
<em>Oranje.</em> Deze groep leest en interpreteert de ARM-toetsen.  </li>
<li>
<em>Groen.</em> Deze groep behandelt de led-rij.  </li>
</ul>
</li>
<li>
<em>FreeRTOS-mechanismen.</em> De inter-proces-communicatie (tussen de tasks dus) met FreeRTOS-functies is ook in kleur weergegeven. Zo zie je welke tasks welke data naar elkaar sturen.  </li>
<li>
<em>Source-files.</em> De gestippelde blokjes geven aan in welke c-files de tasks gecodeerd zijn.  </li>
<li>
<em>IRQ.</em> Niet alle blokjes zijn tasks, maar functies, in dit geval interrupt handlers. Deze functies worden door STM32 gegenereerd op het moment dat je op de processor (.ios) hardwarematig een interrupt definieert. Die functie is dan nog leeg, en aan de programmeur om verder 'in te vullen'. In deze applicatie zijn de ARM-toetsen en de UART-input aan interrupts gekoppeld. </li>
</ul>
<p></span></p>
<p><span style="font-family:&apos;Corbel&apos;; font-size:12pt;"><br  />
 </p><h1 style="font-family:&apos;Corbel&apos;;">FreeRTOS en multitasking, de RTOS-basics</h1>
<p></span></p>
<p><span style="font-family:&apos;Corbel&apos;; font-size:12pt;"></span></p>
<p><span style="font-family:&apos;Corbel&apos;; font-size:12pt;">De applicatie is bedoeld om de werking van FreeRTOS te laten zien: het OS en de functionaliteiten daarvan. In het design hierboven zie je ze in de tasks beschreven in hun c-functieprototypes.</span></p>
<p><span style="font-family:&apos;Corbel&apos;; font-size:12pt;">Ze zijn allemaal keurig beschreven op de FreeRTOS-site (de <a href="https://www.freertos.org/a00106.html">API-Reference</a> en <a href="https://www.freertos.org/Documentation/RTOS_book.html">boeken en pdf's</a>).</span></p>
<p><span style="font-family:&apos;Corbel&apos;; font-size:12pt;">Laten we eerst eens kijken wat een multitasking OS is en hoe die werkt. NB. Ik ga hier nu niet deze referenties herhalen, maar ga alleen globaal in op de basis FreeRTOS-zaken als multitasking, synchronisatie- en communicatiemechanismen en bijbehorende functies.</span></p>
<p><span style="font-family:&apos;Corbel&apos;; font-size:12pt;"></p><ul style="font-family:&apos;Corbel&apos;;">
<li>
(Terzijde) <b>FreeRTOS en CMSIS</b>. <br  />
ARM heeft, om zo onafhankelijk mogelijk te zijn van RTOS en processorkeuzes, een eigen softwarelaag gemaakt bovenop FreeRTOS: <a href="https://arm-software.github.io/CMSIS-FreeRTOS/General/html/index.html">RTOS2</a>. '<em>Using this software pack, users can choose between a native FreeRTOS implementation or one that is adhering to the CMSIS-RTOS2 API and using FreeRTOS under the hood.</em>' In de praktijk betekent dit dat zo'n beetje elke FreeRTOS-functie een RTOS2-variant heeft. RTOS2-functies zijn te herkennen aan het voorvoegsel '<em>os</em>', zoals <em>osThreadNew()</em> of <em>osDelay()</em>. Om verwarring te voorkomen gebruiken we in deze applicatie zoveel mogelijk 'native' FreeRTOS-functies. Hier en daar gebruiken we RTOS2-functies, omdat die door STM32CubeIDE automatisch gegenereerd worden, die houden we dus voor het gemak in stand.<br  />
<br  />
 </li>
<li>
<b><a href="https://www.freertos.org/implementation/a00004.html">Multitasking</a></b>. <br  />
FreeRTOS is een realtime <a href="https://www.freertos.org/implementation/a00004.html">multitasking</a> operating system. <em>Realtime</em> betekent dat code gegarandeerd binnen een bepaalde tijd, of op een bepaalde tijd, uitgevoerd wordt. <em>Multitasking</em> of multithreading betekent dat meerdere taken (tasks of threads genoemd) schijnbaar 'tegelijkertijd' uitgevoerd worden, parallel als het ware. Dat kan natuurlijk niet echt, want er is maar 1 processor. Wat er gebeurt, is dat het OS zo snel tussen tasks swicht, dat het lijkt of taken inderdaad gelijktijdig uitgevoerd worden. Dit heet <b>context switch</b>, waar we zo op door gaan.<br  />
 <img src="./../rtos.png" alt="realtime_os" style="margin-left:30px;" width="50%" class="inline"/> <br  />
<br  />
 </li>
<li>
<p class="startli"><b>Tasks</b> (of <b>threads</b>). <br  />
Een <a href="https://www.freertos.org/taskandcr.html">task</a> is qua code niets anders dan een functie met een oneindige while(1)-loop.<br  />
 '<em>Each task executes within its own context with no coincidental dependency on other tasks within the system or the RTOS scheduler itself. Only one task within the application can be executing at any point in time and the real time RTOS scheduler is responsible for deciding which task this should be. The RTOS scheduler may therefore repeatedly start and stop each task (swap each task in and out) as the application executes. As a task has no knowledge of the RTOS scheduler activity it is the responsibility of the real time RTOS scheduler to ensure that the processor context (register values, stack contents, etc) when a task is swapped in is exactly that as when the same task was swapped out. To achieve this each task is provided with its own stack. When the task is swapped out the execution context is saved to the stack of that task so it can also be exactly restored when the same task is later swapped back in.</em>' <br  />
Dus, een task is een functie die zich gedraagt als een aparte applicatie, met zijn eigen geheugenruimte. De <b>scheduler</b> van het OS switcht tussen deze tasks, wat <a href="https://www.freertos.org/implementation/a00006.html">context switch</a> heet. <br  />
 <img src="../context_switch.png" alt="context switch" style="margin-left:30px;" width="25%" class="inline"/> <br  />
Sommige tasks zullen belangrijker zijn dan ander, dus wil je dat die belangrijke tasks meer processortijd krijgen. Dat wordt gedaan met prioriteiten. Een task met een hogere prioriteit krijgt dan meer processortijd van het OS.  </p><ul>
<li>
Een task kan de volgende status hebben: <ul>
<li>
<b>Running:</b> deze tasks is aan de gang. Het OS geeft hem de beurt, en de task heeft de processor tot zijn beschikking. </li>
<li>
<b>Ready:</b> deze task is klaar om 'te gaan' (hij is niet blocked, noch is hij suspended) maar het OS laat een andere task, bv. met een hogere prioriteit, runnen. </li>
<li>
<b>Blocked / waiting:</b> een task is blocked als hij wacht op een event (bv. een bericht of mutex) van een andere task.  </li>
<li>
<b>Suspended:</b> deze task is op 'pauze' gezet. Het OS negeert deze tasks, totdat hij weer op <em>Resume</em> gezet is. </li>
</ul>
</li>
</ul>
<ul>
<li>
Code. <ul>
<li>
<em>Een task aanmaken:</em> taskhandle = <a href="https://arm-software.github.io/CMSIS_5/RTOS2/html/group__CMSIS__RTOS__ThreadMgmt.html#ga48d68b8666d99d28fa646ee1d2182b8f">osThreadNew()</a> (De FreeRTOS-variant is <a href="https://www.freertos.org/a00125.html">xTaskCreate()</a>)<br  />
Om een task aan te kunnen maken heeft het OS meerdere argumenten nodig, zoals: de naam van de functie, de hoeveelheid geheugen die je de taak meegeeft, de prioriteit die je hem toekent en nog wat zaken.  </li>
<li>
<em>Taskpriority bepalen:</em> <a href="https://www.freertos.org/a00129.html">vTaskPrioritySet(handle, prio)</a> </li>
<li>
<em>Task vertragen (context switch afdwingen):</em> <a href="https://www.freertos.org/a00127.html">vTaskDelay(clockticks)</a>. Wij gebruiken meestal: <a href="https://arm-software.github.io/CMSIS_5/RTOS2/html/group__CMSIS__RTOS__Wait.html#gaf6055a51390ef65b6b6edc28bf47322e">osDelay(clockticks)</a>. Wat ook kan: <a href="https://www.freertos.org/a00020.html#taskYIELD">taskYIELD()</a>, hiermee forceer je een context switch. </li>
<li>
<em>Zie:</em> <a class="el" href="admin_8c.html" title="Bestaat uit 3 onderdelen:   Deel 1. Initialisatieoutput naar uart en lcd-scherm.  Deel 2....">admin.c</a>, <a class="el" href="ledjes_8c.html" title="Laat de werking van mutexes en tasknotification zien.  Demonstreert: , xSemaphoreTake(),...">ledjes.c</a> <br  />
<br  />
 </li>
</ul>
</li>
</ul>
<p class="endli"></p>
</li>
</ul>
<p></span></p>
<p><span style="font-family:&apos;Corbel&apos;; font-size:12pt;"><br  />
 </p><h1 style="font-family:&apos;Corbel&apos;;">FreeRTOS: de mechanismen in de applicatie</h1>
<p></span></p>
<p><span style="font-family:&apos;Corbel&apos;; font-size:12pt;"></span></p>
<p><span style="font-family:&apos;Corbel&apos;; font-size:12pt;"></p><ul style="font-family:&apos;Corbel&apos;;">
<li>
<p class="startli"><b>Algemeen.</b> Voor de synchronisatie en communicatie <em>tussen</em> tasks gebruiken we 4 mechanismen: <em>mutexes</em> voor <u>synchronisatie</u>, en <em>notifications, events</em> en <em>queues</em> voor <u>communicatie</u>.<br  />
<br  />
</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b><a href="https://www.freertos.org/a00113.html">Mutual Exclusion Semaphores (mutexes)</a>.</b> <br  />
Met een Mutual Exclusion Semaphore, meestal <b>mutex</b> genoemd, zorg je ervoor dat een 'shared resource' (denk aan: printer of wc of ledjes) niet tegelijkertijd door meerdere processen gebruikt kan worden (hence: mutual exluded). Bij een printer wil je dat eerst de ene printjob afgehandeld wordt voordat de volgende printjob aan de beurt komt. Bij een wc wil je liever niet dat een ander van het toilet gebruik maakt terwijl jij er net op zit. Anders gezegd: je wil dat dit soort 'gedeelde resources' <em>gesynchroniseerd</em> kunnen worden. Bij een wc is dit het slotje op de deur: rood betekent 'bezet', groen betekent: 'vrij'.<br  />
 <img src="../vrij-bezet.png" alt="mutex" style="margin-left:30px;" width="15%" class="inline"/> <br  />
In de applicatie wordt een <em>mutex</em> gebruikt om te ledjes te synchroniseren. Kijk in het design naar het groene gedeelte. Daar zie je dat meerdere tasks tegelijkertijd naar de ledjes willen schrijven. Om ervoor te zorgen dat ze niet allemaal dwars door elkaar gaan rammen, is er een mutex aangemaakt. Een task kan pas naar de leds schrijven als de 'deur op groen' staat. De task wacht op het OS tot hij erin mag. Zolang de mutex 'bezet' is door een andere task, geeft het OS de beurt aan een andere task. De wachtende task blijft dan <a href="https://www.freertos.org/RTOS-task-states.html">blocked</a>.</p>
<ul>
<li>
<em>Aanmaken:</em> handle = <a href="https://www.freertos.org/CreateMutex.html">xSemaphoreCreateMutex();</a> </li>
<li>
<em>Aanvragen (ik wil erin...):</em> <a href="https://www.freertos.org/a00122.html">xSemaphoreTake(handle);</a> </li>
<li>
<em>Vrijgeven (ik ben klaar...):</em> <a href="https://www.freertos.org/a00123.html">xSemaphoreGive(handle);</a> </li>
<li>
<em>Zie:</em> <a class="el" href="admin_8c.html" title="Bestaat uit 3 onderdelen:   Deel 1. Initialisatieoutput naar uart en lcd-scherm.  Deel 2....">admin.c</a>, <a class="el" href="ledjes_8c.html" title="Laat de werking van mutexes en tasknotification zien.  Demonstreert: , xSemaphoreTake(),...">ledjes.c</a> <br  />
<br  />
 </li>
</ul>
</li>
<li>
<b><a href="https://www.freertos.org/RTOS-task-notification-API.html">Notifications.</a></b><br  />
Met notifications maak je een virtuele verbinding naar een andere task. De ontvangende task wacht (en is dus <em>'blocked'</em>) op het bericht van de versturende taak. Dat bericht kan een signalering zijn (net als 'tikkertje'), of een waarde. Om een notificatie te doen, moet de task die stuurt eerst de taskhandle van de ontvanger verkrijgen. De ontvangende taak wacht gewoon, en aan de code kun je niet zien op welke task hij wacht.<br  />
 <img src="../notify.jfif" alt="notification" style="margin-left:30px;" width="20%" class="inline"/> <br  />
<em>Let op. Bij queues en events stuur je niet een bericht naar een task, maar naar een specifieke queue-handle of een event-handle; elke taak kan naar die handle sturen of van die handle ontvangen ('luisteren').</em> <ul>
<li>
<em>Aanmaken:</em> hoeft niet, de handle die nodig is bestaat al: de handle van de task waarnaar verzonden wordt. </li>
<li>
<em>Zenden en ontvangen met een waarde:</em> <a href="https://www.freertos.org/xTaskNotify.html">xTaskNotify(taskhandle)</a> en <a href="https://www.freertos.org/xTaskNotifyWait.html">xTaskNotifyWait()</a> </li>
<li>
<em>Op elkaar laten wachten:</em> <a href="https://www.freertos.org/xTaskNotifyGive.html">xTaskNotifyGive(taskhandle)</a> en <a href="https://www.freertos.org/ulTaskNotifyTake.html">ulTaskNotifyTake()</a> </li>
<li>
<em>Zie:</em> handles.c, <a class="el" href="ledjes_8c.html" title="Laat de werking van mutexes en tasknotification zien.  Demonstreert: , xSemaphoreTake(),...">ledjes.c</a>, <a class="el" href="_a_r_m__keys_8c.html" title="Behandelt de communicatie met de ARM-toetsjes met: Eventgroups, TaskNotify, Interrupt-handling....">ARM_keys.c</a> <br  />
<br  />
 </li>
</ul>
</li>
<li>
<b><a href="https://www.freertos.org/event-groups-API.html">Eventgroups (flags).</a></b> <br  />
Met een event group zet je een waarde - of eigenlijk: een rij bits - op de aangemaakte eventgroup (op de handle dus) - dat doe je met EventGroupSetBits(). Elke bit kun je zien als een event - hence 'event group'. Bijvoorbeeld, bit 1 staat voor de motorstatus (aan of uit, 1 of 0), bit 2 voor de koplampen (aan of uit) etc. <br  />
 <img src="../event.png" alt="eventgroup" style="margin-left:30px;" width="20%" class="inline"/> <br  />
 Met EventGroupWaitBits() worden de bits uitgelezen. Je kunt alle bits uitlezen, of alleen op een specifieke bit (event) wachten, bijvoorbeeld: de motortask wacht tot de motor aangezet wordt, dus reageert op bit 1. Je kunt dan aan het OS aangeven of het bit gecleared moet worden of niet. De applicatie doet het simpeler: nadat een ARM-key gepressed is, wordt een interrupt gegeneerd. In de ISR wordt bepaald welke key gedrukt is, en die key-waarde (int) wordt op de eventgroup-handle gezet (met ...SendFromISR). In <a class="el" href="_a_r_m__keys_8c.html" title="Behandelt de communicatie met de ARM-toetsjes met: Eventgroups, TaskNotify, Interrupt-handling....">ARM_keys.c</a> wordt die waarde in zijn geheel uitgelezen. Er wordt dus verder niks met afzonderlijke bits gedaan.  <ul>
<li>
<em>Aanmaken:</em> handle = <a href="https://www.freertos.org/xEventGroupCreate.html">xEventGroupCreate()</a> </li>
<li>
<em>Zenden:</em> <a href="https://www.freertos.org/xEventGroupSetBits.html">xEventGroupSetBits(handle)</a> en <a href="https://www.freertos.org/xEventGroupSetBitsFromISR.html">xEventGroupSetBitsFromISR(handle)</a> </li>
<li>
<em>Ontvangen:</em> <a href="https://www.freertos.org/xEventGroupWaitBits.html">xEventGroupWaitBits(handle)</a> </li>
<li>
<em>Zie:</em> <a class="el" href="admin_8c.html" title="Bestaat uit 3 onderdelen:   Deel 1. Initialisatieoutput naar uart en lcd-scherm.  Deel 2....">admin.c</a>, <a class="el" href="stm32f4xx__it_8c.html" title="Interrupt Service Routines.">stm32f4xx_it.c</a>, <a class="el" href="_a_r_m__keys_8c.html" title="Behandelt de communicatie met de ARM-toetsjes met: Eventgroups, TaskNotify, Interrupt-handling....">ARM_keys.c</a> <br  />
<br  />
 </li>
</ul>
</li>
<li>
<b><a href="https://www.freertos.org/a00018.html">Queues.</a></b> <br  />
Een queue is een rij/array van elementen. Net als karretjes bij een kassa. Een element kan een char zijn, of een structure, of een pointer, whatever. Bij het aanmaken geef je aan hoeveel elementen de queue moet bevatten (hoeveel karretjes er in de rij kunnen), en hoe groot (hoeveel bytes) elk element is (hoeveel in elk karretje past). Daarmee weet het OS genoeg. Een queue werkt via FIFO (first in, first out: default) of LIFO. Met <em>send</em> zet je een element op de queue; het OS zorgt (bij FIFO) dat dat element keurig achter het vorige element terecht komt. <img src="../queue.png" alt="queue" style="margin-left:30px;" width="30%" class="inline"/> <br  />
 Bij <em>receive</em> wordt het eerst verstuurde element van de queue gehaald (wil je dat niet, dan moet je <em>peek</em> gebruiken). In de applicatie wordt een queue gebruikt om de toetsaanslagen op de UART op te vangen; dit wordt gedaan door de ISR (met ...SendFromISR in <a class="el" href="main_8c.html" title=": Main program body">main.c</a>). Met deze queue wordt een soort buffer gecreëerd, zodat er geen toetsaanslagen verloren gaan. De ontvangende kant (<a class="el" href="_u_a_r_t__keys_8c.html" title="Behandelt de communicatie met de UART.  Demonstreert: IRQ-handling, queue-handling,...">UART_keys.c</a>) leest elke character (toets) direct uit, tot ie een linefeed '\n' tegenkomt - dan gaat ie de string naar een andere task versturen met xTaskNotify(). <ul>
<li>
<em>Aanmaken:</em> handle = <a href="https://www.freertos.org/a00116.html">xQueueCreate()</a>  </li>
<li>
<em>Op queue zetten:</em> <a href="https://www.freertos.org/a00117.html">xQueueSend(handle)</a> en <a href="https://www.freertos.org/a00119.html">xQueueSendFromISR(handle)</a> </li>
<li>
<em>Ontvangen:</em> <a href="https://www.freertos.org/a00118.html">xQueueReceive(handle)</a> </li>
<li>
<em>Zie:</em> <a class="el" href="admin_8c.html" title="Bestaat uit 3 onderdelen:   Deel 1. Initialisatieoutput naar uart en lcd-scherm.  Deel 2....">admin.c</a>, <a class="el" href="main_8c.html" title=": Main program body">main.c</a>, <a class="el" href="_u_a_r_t__keys_8c.html" title="Behandelt de communicatie met de UART.  Demonstreert: IRQ-handling, queue-handling,...">UART_keys.c</a><br  />
 </li>
</ul>
</li>
</ul>
<p></span></p>
<p><span style="font-family:&apos;Corbel&apos;; font-size:12pt;"><br  />
 </p><h1 style="font-family:&apos;Corbel&apos;;">Sourcefiles: samenhang van de applicatie</h1>
<p></span></p>
<p><span style="font-family:&apos;Corbel&apos;; font-size:12pt;"></span></p>
<p><span style="font-family:&apos;Corbel&apos;; font-size:12pt;">Hieronder zie je de voor deze applicatie belangrijkste bestanden. De applicatie bevindt zich in de map <b>Core</b>, en wel hoofdzakelijk in de map <b>MyApp</b>, die weer verdeeld is in App en Ports. Daarnaast zie je in Core nog de map <b>Src</b>, die door STM gegenereerde bestanden bevat. </p><table border="1" style="margin-left:30px; font-family:&apos;Corbel&apos;; font-size:11pt; background-color: #f6f8ff; border-style:solid;">
<tr>
<td><b>[Core/Src]</b></td><td><b>Bevat de door STM gegenereerde bestanden</b></td></tr>
<tr>
<td><a class="el" href="main_8c.html" title=": Main program body">main.c</a></td><td>ISR voor UART (<a class="el" href="_u_a_r_t__keys_8c.html" title="Behandelt de communicatie met de UART.  Demonstreert: IRQ-handling, queue-handling,...">UART_keys.c</a>), blijf ik verder zoveel mogelijk uit...</td></tr>
<tr>
<td><a class="el" href="stm32f4xx__it_8c.html" title="Interrupt Service Routines.">stm32f4xx_it.c</a></td><td>ISR voor <a class="el" href="_a_r_m__keys_8c.html" title="Behandelt de communicatie met de ARM-toetsjes met: Eventgroups, TaskNotify, Interrupt-handling....">ARM_keys.c</a></td></tr>
<tr>
<td>&#160;</td><td></td></tr>
<tr>
<td><b>[Core/MyApp/App]</b></td><td><b>Bevat de applicatie-code (Michiel Scager)</b></td></tr>
<tr>
<td><a class="el" href="admin_8c.html" title="Bestaat uit 3 onderdelen:   Deel 1. Initialisatieoutput naar uart en lcd-scherm.  Deel 2....">admin.c</a></td><td>versie-beheer<br  />
kleine algemene functies;<br  />
<b>alle handles en alle taken (tasks, threads) worden hier aangemaakt</b></td></tr>
<tr>
<td><a class="el" href="admin_8h.html" title="Bevat de defines &amp; externals voor deze applicatie.">admin.h</a></td><td>#defines, structs, externals, etc.</td></tr>
<tr>
<td><a class="el" href="gps_8c.html" title="Behandelt de gps input-strings (NMEA-protocol) van UART1.  Demonstreert: xMessageBufferRead()   Aan U...">gps.c</a></td><td>verwerking van de inkomende GPS-data (UART)</td></tr>
<tr>
<td><a class="el" href="ledjes_8c.html" title="Laat de werking van mutexes en tasknotification zien.  Demonstreert: , xSemaphoreTake(),...">ledjes.c</a></td><td>hier gaan wat tasks met ledjes spelen</td></tr>
<tr>
<td><a class="el" href="_u_a_r_t__keys_8c.html" title="Behandelt de communicatie met de UART.  Demonstreert: IRQ-handling, queue-handling,...">UART_keys.c</a></td><td>afhandeling UART-input via ISR in <a class="el" href="main_8c.html" title=": Main program body">main.c</a></td></tr>
<tr>
<td><a class="el" href="_a_r_m__keys_8c.html" title="Behandelt de communicatie met de ARM-toetsjes met: Eventgroups, TaskNotify, Interrupt-handling....">ARM_keys.c</a></td><td>afhandeling ARM-toetsen via ISR in <a class="el" href="stm32f4xx__it_8c.html" title="Interrupt Service Routines.">stm32f4xx_it.c</a></td></tr>
<tr>
<td><a class="el" href="student_8c.html" title="Hier kunnen studenten hun eigen tasks aanmaken.">student.c</a></td><td>speeltuin voor studenten</td></tr>
<tr>
<td>&#160;</td><td></td></tr>
<tr>
<td><b>[Core/Myapp/Ports]</b></td><td><b>Bevat ARM-port-functies (Franc van der Bent)</b></td></tr>
<tr>
<td>buzzer.c</td><td></td></tr>
<tr>
<td>uart.c</td><td></td></tr>
<tr>
<td>leds.c</td><td></td></tr>
<tr>
<td>lcd.c</td><td></td></tr>
<tr>
<td>keys.c</td><td></td></tr>
</table>
<p></span></p>
<p><span style="font-family:&apos;Corbel&apos;; font-size:12pt;"><br  />
 </span></p>
</div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"></a>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
