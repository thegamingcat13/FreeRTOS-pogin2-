\doxysection{Event\+Group }
\hypertarget{group___event_group}{}\label{group___event_group}\index{EventGroup@{EventGroup}}
\doxysubsubsection*{Topics}
\begin{DoxyCompactItemize}
\item 
\item \contentsline{section}{Event\+Group\+Handle\+\_\+t }{\pageref{group___event_group_handle__t}}{}

\item 
\item \contentsline{section}{x\+Event\+Group\+Create }{\pageref{group__x_event_group_create}}{}

\item 
\item \contentsline{section}{x\+Event\+Group\+Wait\+Bits }{\pageref{group__x_event_group_wait_bits}}{}

\item 
\item \contentsline{section}{x\+Event\+Group\+Clear\+Bits }{\pageref{group__x_event_group_clear_bits}}{}

\item 
\item \contentsline{section}{x\+Event\+Group\+Clear\+Bits\+From\+ISR }{\pageref{group__x_event_group_clear_bits_from_i_s_r}}{}

\item 
\item \contentsline{section}{x\+Event\+Group\+Set\+Bits }{\pageref{group__x_event_group_set_bits}}{}

\item 
\item \contentsline{section}{x\+Event\+Group\+Set\+Bits\+From\+ISR }{\pageref{group__x_event_group_set_bits_from_i_s_r}}{}

\item 
\item \contentsline{section}{x\+Event\+Group\+Sync }{\pageref{group__x_event_group_sync}}{}

\item 
\item \contentsline{section}{x\+Event\+Group\+Get\+Bits }{\pageref{group__x_event_group_get_bits}}{}

\item 
\item \contentsline{section}{x\+Event\+Group\+Get\+Bits\+From\+ISR }{\pageref{group__x_event_group_get_bits_from_i_s_r}}{}

\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
An event group is a collection of bits to which an application can assign a meaning. For example, an application may create an event group to convey the status of various CAN bus related events in which bit 0 might mean "{}\+A CAN message has been received and is ready for processing"{}, bit 1 might mean "{}\+The application has queued a message that is ready for sending onto the CAN network"{}, and bit 2 might mean "{}\+It is time to send a SYNC message onto the \+CAN network"{} etc. A task can then test the bit values to see which events are active, and optionally enter the Blocked state to wait for a specified bit or a group of specified bits to be active. To continue the CAN bus example, a CAN controlling task can enter the Blocked state (and therefore not consume any processing time) until either bit 0, bit 1 or bit 2 are active, at which time the bit that was actually active would inform the task which action it had to take (process a received message, send a message, or send a SYNC).

The event groups implementation contains intelligence to avoid race conditions that would otherwise occur were an application to use a simple variable for the same purpose. This is particularly important with respect to when a bit within an event group is to be cleared, and when bits have to be set and then tested atomically -\/ as is the case where event groups are used to create a synchronisation point between multiple tasks (a \textquotesingle{}rendezvous\textquotesingle{}). \input{group___event_group_handle__t}
\input{group__x_event_group_create}
\input{group__x_event_group_wait_bits}
\input{group__x_event_group_clear_bits}
\input{group__x_event_group_clear_bits_from_i_s_r}
\input{group__x_event_group_set_bits}
\input{group__x_event_group_set_bits_from_i_s_r}
\input{group__x_event_group_sync}
\input{group__x_event_group_get_bits}
\input{group__x_event_group_get_bits_from_i_s_r}
